---
interface Props {
  placeholder?: string;
  size?: 'default' | 'large';
  apiEndpoint?: string;
}

const {
  placeholder = 'Search programs...',
  size = 'default',
  apiEndpoint = 'https://baytides-link-checker.azurewebsites.net/api/assistant'
} = Astro.props;

const sizeClasses = size === 'large'
  ? 'py-4 pl-12 pr-12 text-lg'
  : 'py-3 pl-10 pr-10';
---

<div class="relative search-container">
  <label for="search-input" class="sr-only">Search programs</label>

  <!-- Search icon -->
  <svg
    class={`search-icon absolute left-3 top-1/2 -translate-y-1/2 text-neutral-400 ${size === 'large' ? 'w-6 h-6 left-4' : 'w-5 h-5'}`}
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"
    aria-hidden="true"
  >
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      stroke-width="2"
      d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
    />
  </svg>

  <!-- AI indicator (shows when AI is processing) -->
  <div id="ai-indicator" class={`hidden absolute top-1/2 -translate-y-1/2 ${size === 'large' ? 'right-4' : 'right-3'}`}>
    <span class="inline-flex items-center gap-1 text-xs text-primary-600 dark:text-primary-300 bg-primary-50 dark:bg-primary-900/50 px-2 py-0.5 rounded-full">
      <svg class="w-3 h-3 animate-pulse" fill="currentColor" viewBox="0 0 24 24">
        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
      </svg>
      <span id="ai-status-text">AI</span>
    </span>
  </div>

  <!-- Loading spinner -->
  <div id="search-loading" class={`hidden absolute top-1/2 -translate-y-1/2 ${size === 'large' ? 'right-4' : 'right-3'}`}>
    <svg class="w-5 h-5 animate-spin text-primary-600" fill="none" viewBox="0 0 24 24">
      <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
      <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
    </svg>
  </div>

  <input
    type="search"
    id="search-input"
    class={`search-input ${sizeClasses}`}
    placeholder={placeholder}
    autocomplete="off"
  />

  <!-- Search hints -->
  <div id="search-hints" class="hidden absolute top-full left-0 right-0 mt-2 bg-white dark:bg-neutral-800 rounded-lg shadow-lg border border-neutral-200 dark:border-neutral-700 p-3 z-50">
    <p class="text-xs text-neutral-500 dark:text-neutral-400 mb-2">Try searching for:</p>
    <div class="flex flex-wrap gap-2 mb-3">
      <button type="button" class="search-hint-btn" data-type="keyword">food assistance</button>
      <button type="button" class="search-hint-btn" data-type="keyword">utility bill help</button>
      <button type="button" class="search-hint-btn" data-type="keyword">healthcare</button>
      <button type="button" class="search-hint-btn" data-type="keyword">senior programs</button>
    </div>
    <p class="text-xs text-neutral-500 dark:text-neutral-400 mb-2">Or ask a question:</p>
    <div class="flex flex-wrap gap-2">
      <button type="button" class="search-hint-btn ai-hint" data-type="ai">I'm a senior who needs help with bills</button>
      <button type="button" class="search-hint-btn ai-hint" data-type="ai">Low-income family looking for food</button>
    </div>
  </div>
</div>

<!-- Store API endpoint for client script -->
<script type="application/json" id="search-config">
  {JSON.stringify({ apiEndpoint })}
</script>

<!-- Fuse.js for fuzzy search -->
<script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0/dist/fuse.min.mjs" type="module"></script>

<script type="module">
  import Fuse from 'https://cdn.jsdelivr.net/npm/fuse.js@7.0.0/dist/fuse.esm.min.js';

  // Load config
  const configEl = document.getElementById('search-config');
  const config = JSON.parse(configEl?.textContent || '{}');
  const API_ENDPOINT = config.apiEndpoint;

  // Build search index from program cards
  const cards = document.querySelectorAll('[data-category]');
  const programs = Array.from(cards).map((card, index) => {
    const nameEl = card.querySelector('h3');
    const descEl = card.querySelector('p');
    const areaEl = card.querySelector('[class*="text-neutral-500"]');
    const id = card.id?.replace('program-', '') || '';

    return {
      index,
      element: card,
      id,
      name: nameEl?.textContent?.trim() || '',
      description: descEl?.textContent?.trim() || '',
      category: card.getAttribute('data-category') || '',
      groups: card.getAttribute('data-groups')?.split(',') || [],
      area: areaEl?.textContent?.trim() || '',
      text: card.textContent?.trim() || ''
    };
  });

  // Configure Fuse.js with weighted search
  const fuse = new Fuse(programs, {
    keys: [
      { name: 'name', weight: 0.4 },
      { name: 'description', weight: 0.3 },
      { name: 'category', weight: 0.2 },
      { name: 'area', weight: 0.1 }
    ],
    threshold: 0.4,
    distance: 100,
    minMatchCharLength: 2,
    includeScore: true,
    includeMatches: true,
    ignoreLocation: true,
    useExtendedSearch: true
  });

  const searchInput = document.getElementById('search-input') as HTMLInputElement;
  const searchHints = document.getElementById('search-hints');
  const aiIndicator = document.getElementById('ai-indicator');
  const aiStatusText = document.getElementById('ai-status-text');
  const searchLoading = document.getElementById('search-loading');
  const hintButtons = document.querySelectorAll('.search-hint-btn');

  let activeCategory = 'all';
  let debounceTimer: ReturnType<typeof setTimeout>;
  let isAISearching = false;
  let lastAIQuery = '';

  // Detect if query needs AI assistance
  function isComplexQuery(query: string): boolean {
    const trimmed = query.trim();

    // Demographic terms that should trigger AI even as single words
    // These map to specific group filters that fuzzy search might miss
    // Comprehensive list based on groups.yml categories
    const demographicTerms = new RegExp('^(' + [
      // Income-eligible synonyms
      'low.?income', 'ebt', 'snap', 'calfresh', 'calworks', 'medi.?cal', 'medicaid', 'ssi', 'ssdi', 'welfare', 'poor', 'poverty',
      // Seniors synonyms
      'senior', 'seniors', 'elderly', 'older.?adult', 'retiree', 'retired', 'aging',
      // Youth synonyms
      'youth', 'young', 'teen', 'teenager', 'child', 'children', 'kid', 'kids', 'minor', 'adolescent',
      // College students synonyms
      'student', 'students', 'college', 'university', 'grad.?student', 'undergraduate', 'graduate',
      // Veterans synonyms
      'veteran', 'veterans', 'military', 'army', 'navy', 'marines', 'air.?force', 'coast.?guard', 'active.?duty', 'reservist',
      // Families synonyms
      'family', 'families', 'parent', 'parents', 'mother', 'father', 'mom', 'dad', 'single.?parent',
      // Disability synonyms
      'disabled', 'disability', 'disabilities', 'handicapped', 'blind', 'deaf', 'wheelchair', 'ada',
      // LGBTQ+ synonyms
      'lgbtq?', 'lgbt', 'gay', 'lesbian', 'bisexual', 'transgender', 'queer', 'trans', 'nonbinary', 'non.?binary', 'pansexual', 'asexual', 'intersex', 'pride',
      // First responders synonyms
      'first.?responder', 'firefighter', 'police', 'officer', 'cop', 'emt', 'paramedic',
      // Teachers synonyms
      'teacher', 'teachers', 'educator', 'professor', 'instructor',
      // Job seekers synonyms
      'unemployed', 'job.?seeker', 'jobless', 'laid.?off',
      // Immigrants synonyms
      'immigrant', 'immigrants', 'refugee', 'refugees', 'undocumented', 'daca', 'dreamer', 'asylum', 'migrant',
      // Unhoused synonyms
      'homeless', 'unhoused', 'houseless', 'unsheltered', 'shelter',
      // Pregnant/Women synonyms
      'pregnant', 'pregnancy', 'expecting', 'expectant', 'prenatal', 'maternal', 'woman', 'women', 'female',
      // Caregivers synonyms
      'caregiver', 'caregivers',
      // Foster youth synonyms
      'foster', 'foster.?youth', 'foster.?care', 'aged.?out',
      // Formerly incarcerated synonyms
      'incarcerated', 'formerly.?incarcerated', 'reentry', 'ex.?offender', 'parolee', 'probation',
      // Nonprofits
      'nonprofit', 'non.?profit', 'ngo', 'charity'
    ].join('|') + ')$', 'i');

    if (demographicTerms.test(trimmed)) {
      return true; // Single demographic terms should use AI
    }

    // Simple patterns that don't need AI
    const simplePatterns = [
      /^\d{5}$/,                          // ZIP code
      /^[a-zA-Z]{1,20}$/,                 // Single word (generic)
      /^[a-zA-Z]+\s+[a-zA-Z]+$/,          // Two words
      /^(food|health|housing|utilities|transportation|education|legal|finance|technology|recreation|community)$/i, // Category names
    ];

    for (const pattern of simplePatterns) {
      if (pattern.test(trimmed)) return false;
    }

    // Complex query indicators
    const complexIndicators = [
      trimmed.length > 30,                              // Long queries
      /\b(i'm|i am|my|me|we|our)\b/i.test(trimmed),    // First person
      /\b(need|looking for|help with|want|qualify)\b/i.test(trimmed), // Intent words
      // Demographics - expanded to include more identity terms
      /\b(senior|elderly|disabled|veteran|family|child|low.?income|immigrant|refugee|homeless|unhoused)\b/i.test(trimmed),
      /\b(lgbtq?|gay|lesbian|bisexual|transgender|queer|nonbinary|trans)\b/i.test(trimmed), // LGBTQ+ terms
      /\b(woman|women|female|mother|pregnant|expecting)\b/i.test(trimmed), // Women-specific
      /\b(student|college|university|graduate|undergraduate)\b/i.test(trimmed), // Students
      /\b(teacher|educator|nurse|first.?responder|firefighter|police|emt)\b/i.test(trimmed), // Professions
      /\b(foster|formerly.?incarcerated|reentry|caregiver)\b/i.test(trimmed), // Special circumstances
      /\b(years?\s+old|\d{2}\s+year)\b/i.test(trimmed), // Age mentions
      /\b(living\s+in|from|near)\b/i.test(trimmed),    // Location context
      trimmed.split(/\s+/).length >= 5,                 // 5+ words
    ];

    const complexCount = complexIndicators.filter(Boolean).length;
    return complexCount >= 2;
  }

  // Track active category filter
  document.addEventListener('click', (e) => {
    const filterBtn = (e.target as Element).closest('[data-filter]');
    if (filterBtn) {
      activeCategory = filterBtn.getAttribute('data-filter') || 'all';
      performSearch();
    }
  });

  function showLoading(show: boolean) {
    if (show) {
      searchLoading?.classList.remove('hidden');
      aiIndicator?.classList.add('hidden');
    } else {
      searchLoading?.classList.add('hidden');
    }
  }

  function showAIIndicator(status: string) {
    aiIndicator?.classList.remove('hidden');
    searchLoading?.classList.add('hidden');
    if (aiStatusText) aiStatusText.textContent = status;
  }

  function hideAIIndicator() {
    aiIndicator?.classList.add('hidden');
  }

  async function performAISearch(query: string) {
    if (isAISearching || query === lastAIQuery) return;

    isAISearching = true;
    lastAIQuery = query;
    showLoading(true);

    try {
      const response = await fetch(API_ENDPOINT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: `Find programs matching this request. Return ONLY the program names that match, nothing else. Request: ${query}`,
          history: [],
          mode: 'filter' // Tell the API we just want filtering, not conversation
        })
      });

      if (!response.ok) throw new Error('AI search failed');

      const data = await response.json();

      // Extract program IDs/names from AI response
      const matchedPrograms = data.programs || [];
      const matchedIds = new Set(matchedPrograms.map((p: any) =>
        (p.id || p.name || '').toLowerCase().replace(/[^a-z0-9]+/g, '-')
      ));

      // Also extract any program names mentioned in the message
      const messageText = data.message || '';
      programs.forEach(p => {
        if (messageText.toLowerCase().includes(p.name.toLowerCase())) {
          matchedIds.add(p.id);
        }
      });

      // Filter cards based on AI results
      let visibleCount = 0;
      programs.forEach(p => {
        const matchesAI = matchedIds.size === 0 || matchedIds.has(p.id);
        const matchesCategory = activeCategory === 'all' || p.category === activeCategory;
        const shouldShow = matchesAI && matchesCategory;

        (p.element as HTMLElement).style.display = shouldShow ? '' : 'none';
        if (shouldShow) visibleCount++;
      });

      // If AI returned programs, show them; otherwise fall back to fuzzy search
      if (matchedIds.size > 0 && visibleCount > 0) {
        showAIIndicator(`AI found ${visibleCount}`);
        updateResultsCount(visibleCount, query, true);
      } else {
        // Fall back to fuzzy search
        hideAIIndicator();
        performFuzzySearch(query);
      }

    } catch (error) {
      console.error('AI search error:', error);
      // Fall back to fuzzy search on error
      hideAIIndicator();
      performFuzzySearch(query);
    } finally {
      isAISearching = false;
      showLoading(false);
    }
  }

  function performFuzzySearch(query: string) {
    if (!query) {
      // No search query - show all (respect category filter)
      programs.forEach(p => {
        const matchesCategory = activeCategory === 'all' || p.category === activeCategory;
        // Also respect location filter if active
        const locationHidden = p.element.hasAttribute('data-location-hidden');
        (p.element as HTMLElement).style.display = (matchesCategory && !locationHidden) ? '' : 'none';
      });
      hideAIIndicator();
    } else {
      // Fuzzy search with Fuse.js
      const results = fuse.search(query);
      const matchedIndices = new Set(results.map(r => r.item.index));

      programs.forEach(p => {
        const matchesSearch = matchedIndices.has(p.index);
        const matchesCategory = activeCategory === 'all' || p.category === activeCategory;
        const locationHidden = p.element.hasAttribute('data-location-hidden');
        (p.element as HTMLElement).style.display = (matchesSearch && matchesCategory && !locationHidden) ? '' : 'none';
      });
    }

    // Update count
    const visibleCount = document.querySelectorAll('[data-category]:not([style*="display: none"])').length;
    updateResultsCount(visibleCount, query, false);
  }

  function updateResultsCount(count: number, query: string, isAI: boolean) {
    const counter = document.getElementById('results-count');
    if (counter) {
      const queryInfo = query ? ` for "${query}"` : '';
      const aiInfo = isAI ? ' (AI-powered)' : '';
      counter.textContent = `${count} program${count !== 1 ? 's' : ''} found${queryInfo}${aiInfo}`;
    }
  }

  function performSearch() {
    const query = searchInput?.value.trim() || '';

    // Clear AI state for new searches
    if (query !== lastAIQuery) {
      hideAIIndicator();
    }

    if (isComplexQuery(query)) {
      // Use AI for complex queries
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => performAISearch(query), 500);
    } else {
      // Use fuzzy search for simple queries
      performFuzzySearch(query);
    }
  }

  // Debounced search on input
  searchInput?.addEventListener('input', () => {
    clearTimeout(debounceTimer);
    const query = searchInput.value.trim();

    // Immediate fuzzy search for simple queries
    if (!isComplexQuery(query)) {
      debounceTimer = setTimeout(performSearch, 150);
    } else {
      // Longer delay for AI queries to avoid too many API calls
      debounceTimer = setTimeout(performSearch, 600);
    }
  });

  // Show hints on focus if empty
  searchInput?.addEventListener('focus', () => {
    if (!searchInput.value) {
      searchHints?.classList.remove('hidden');
    }
  });

  // Hide hints on blur (with delay for click)
  searchInput?.addEventListener('blur', () => {
    setTimeout(() => searchHints?.classList.add('hidden'), 200);
  });

  // Hide hints when typing
  searchInput?.addEventListener('input', () => {
    if (searchInput.value) {
      searchHints?.classList.add('hidden');
    }
  });

  // Handle hint button clicks
  hintButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      searchInput.value = btn.textContent || '';
      searchHints?.classList.add('hidden');
      performSearch();
      searchInput.focus();
    });
  });

  // Listen for location changes to re-apply search
  window.addEventListener('locationChanged', () => {
    if (searchInput.value) {
      performSearch();
    }
  });
</script>

<style>
  .search-hint-btn {
    @apply text-xs px-2 py-1 rounded-full bg-primary-100 dark:bg-primary-900 text-primary-700 dark:text-primary-300 hover:bg-primary-200 dark:hover:bg-primary-800 transition-colors;
  }

  .search-hint-btn.ai-hint {
    @apply bg-neutral-100 dark:bg-neutral-700 text-neutral-700 dark:text-neutral-300 border border-dashed border-neutral-300 dark:border-neutral-600;
  }

  .search-hint-btn.ai-hint:hover {
    @apply bg-primary-50 dark:bg-primary-900/50 border-primary-300 dark:border-primary-600 text-primary-700 dark:text-primary-300;
  }
</style>
